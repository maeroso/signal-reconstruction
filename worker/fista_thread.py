import math
import sys
import time
from threading import Thread

import cv2
import numpy
import psutil
from PIL import Image

from global_data import GlobalData


class FISTAThread(Thread):

    def __init__(self, global_data: GlobalData, g: numpy.ndarray):
        super().__init__()
        self.global_data = global_data
        self.signal_array = g
        self.start()

    def s_function(self, signal, threshold):
        if signal >= 0:
            if signal - threshold < 0:
                return 0
            else:
                return signal - threshold
        else:
            if signal + threshold >= 0:
                return 0
            else:
                return signal + threshold

    def run(self):
        f_old = numpy.zeros_like(numpy.matmul(self.global_data.get_transpose_h(), self.signal_array))

        y_old = f_old

        alfa_old = float(1)

        lambda_value = numpy.max(numpy.absolute(
            numpy.matmul(self.global_data.get_transpose_h(), self.signal_array))) * 0.10

        threshold = numpy.absolute(lambda_value / self.global_data.c)

        f_next = 0

        loop_counter = 0

        loop_maximum = 20

        error = 0

        for counter in range(loop_maximum):

            show_warning_message = False

            overload = psutil.cpu_percent(percpu=False, interval=5) > 85

            low_memory = psutil.virtual_memory().free < 600000000

            while overload or low_memory:
                if not show_warning_message:
                    if overload:
                        sys.stdout.write(" [!] CPU load greater than 85%" +
                                         ", fista thread will sleep for 1.5 seconds to avoid overload\n")
                    if low_memory:
                        sys.stdout.write(" [!] There is less than 600Mb of free memory." +
                                         " Fista thread will sleep for 1.5 seconds to avoid overload\n")
                    show_warning_message = True

                time.sleep(.800)

                overload = psutil.cpu_percent(percpu=False, interval=5) > 90

                low_memory = psutil.virtual_memory().free < 250000000

            # TODO esse método pesa 2 GB de RAM, deve ser quebrado em pedaçoes menores para debbug e melhoramentos
            f_next = y_old + numpy.matmul(
                self.global_data.get_transpose_h() * (1 / self.global_data.c),
                numpy.subtract(self.signal_array, numpy.matmul(self.global_data.H, y_old))
            )

            index = 0

            # TODO essa iteração é extremamente demorada, provavelmente dvido a troca de contexto contante,
            #  uma solução se faz necessária
            for signal in f_next:
                f_next[index] = self.s_function(signal, threshold)

                index += 1

            alfa_next = (1 + numpy.sqrt(1 + 4 * math.pow(alfa_old, 2))) / 2

            y_next = f_next + ((alfa_old - 1) / alfa_next) * (f_next - f_old)

            f_old = f_next

            alfa_old = alfa_next

            y_old = y_next

            loop_counter = counter

        sys.stdout.write(" [X] Data about image generated by fista thread -> actual error: " + str(
            error) + "  expected error: <" + str(self.global_data.minimal_error) + "  loop counter: " + str(
            loop_counter) + "\n")

        f_reshaped = f_next.reshape(60, 60)

        normalized = cv2.normalize(src=f_reshaped, alpha=0, beta=255, dst=numpy.zeros_like(f_reshaped),
                                   norm_type=cv2.NORM_MINMAX)

        first_image = Image.fromarray(numpy.uint8(normalized.transpose()), mode='L')

        first_image.save('./images/last_generated_image_by_fista_algorithm.bmp')

        del self
